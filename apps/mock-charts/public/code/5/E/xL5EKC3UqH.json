{"code":"// 支持点击打开对应npm链接\nconst uploadedDataURL = '/asset/get/s/data-1627229866545-v6DvzzMbR.json';\n\nmyChart.showLoading();\n$.getJSON(uploadedDataURL, function (json) {\n myChart.hideLoading();\n const colors = ['#CCCCCC', '#55AF29', '#FFD017', '#B72E00'];\n\n const c = d3.scaleQuantile().domain(d3.range(1, 50)).range(colors);\n const nodes = [...new Set(json.map((item) => [item.source, item.target]).flat())];\n const targets = json.map((item) => item.target);\n const nodeSizeMap = _.countBy(targets);\n const nodesData = nodes.map((node) => ({\n  id: node,\n  name: node,\n  symbolSize: nodeSizeMap[node] || 1,\n }));\n myChart.setOption(\n  (option = {\n   title: {\n    text: 'Antd4 NPM依赖',\n   },\n   animationDurationUpdate: 1500,\n   animationEasingUpdate: 'quinticInOut',\n   tooltip: {},\n   series: [\n    {\n     type: 'graph',\n     layout: 'force',\n     force: {\n      edgeLength: 5,\n      repulsion: 20,\n      gravity: 0.2,\n     },\n     data: nodesData.map(function (node) {\n      return {\n       value: node.symbolSize,\n       name: node.name,\n       symbolSize: node.symbolSize,\n       itemStyle: {\n        color: c(node.symbolSize),\n       },\n      };\n     }),\n     edges: json.map(function (edge) {\n      return {\n       source: edge.source,\n       target: edge.target,\n       symbol: ['none', 'arrow'],\n       symbolSize: 3,\n      };\n     }),\n     label: {\n      position: 'right',\n      show: true,\n      overflow: 'breakAll',\n      width: 200,\n     },\n     emphasis: {\n      focus: 'adjacency',\n     },\n     labelLayout: {\n      hideOverlap: true,\n     },\n     roam: true,\n     lineStyle: {\n      width: 0.5,\n      curveness: 0.3,\n      opacity: 0.7,\n     },\n    },\n   ],\n  }),\n  true\n );\n});\n\nmyChart.on('click', (e) => {\n if (e.seriesType === 'graph' && e.dataType === 'node' && e.name) {\n  window.open(`https://www.npmjs.com/package/${e.name}`);\n }\n});\n\n// 分享ts环境下的依赖关系生成代码, 可自动生成项目下所有依赖的关系字典\n// author 姚元璋\n// import fs from \"fs-extra\";\n// import path from \"path\";\n// import chalk from \"chalk\";\n\n// const argPath = process.argv[2];\n// const depMap: Array<{ source: string; target: string }> = [];\n\n// async function findPackageJson(basePath: string) {\n//   try {\n//     const files = await fs.readdirSync(basePath);\n//     files.forEach(async (file) => {\n//       const depDirPath = path.join(basePath, file);\n//       try {\n//         const info = await fs.statSync(depDirPath);\n//         const isFile = info.isFile();\n//         const isDir = info.isDirectory();\n//         if (isDir) {\n//           await findPackageJson(depDirPath);\n//         } else if (isFile && file === \"package.json\") {\n//           const json = await fs.readJSONSync(depDirPath);\n//           const { name, dependencies } = json;\n//           if (dependencies) {\n//             const depNames = Object.keys(dependencies);\n//             depNames.forEach((target) => {\n//               depMap.push({\n//                 source: name,\n//                 target,\n//               });\n//             });\n//             const data = JSON.stringify(depMap);\n//             console.log(chalk.gray(\"写入数据...\"));\n//             await fs.outputFileSync(`${process.cwd()}/npm_deps.json`, data);\n//           }\n//         }\n//       } catch (e) {\n//         console.log(chalk.redBright(e));\n//       }\n//     });\n//   } catch (e) {\n//     console.log(chalk.redBright(e));\n//   }\n//   return depMap;\n// }\n\n// async function readNodeModules(path: string) {\n//   const nodeModulesPath = `${path}/node_modules`;\n//   await findPackageJson(nodeModulesPath);\n// }\n\n// (async function () {\n//   await readNodeModules(argPath);\n// })();\n"}